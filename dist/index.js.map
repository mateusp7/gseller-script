{"version":3,"sources":["../src/index.ts","../src/helpers/init.ts","../src/helpers/create-app.ts","../src/helpers/download.ts","../src/helpers/example.ts","../src/helpers/install.ts","../src/helpers/is-writeable.ts","../src/helpers/make-dir.ts","../src/helpers/logger.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { Command } from 'commander'\nimport { init } from './helpers/init'\n\nconst program = new Command()\nasync function main() {\n  program\n    .name('gseller')\n    .description('Criar um template teste')\n    .version('1.0.0', '-v, --version', 'display the version number')\n\n  program.addCommand(init)\n  program.parse()\n}\n\nmain()\n","import { Command } from 'commander'\nimport { existsSync } from 'fs'\nimport ora from 'ora'\nimport path from 'path'\n\nimport chalk from 'chalk'\nimport prompts from 'prompts'\nimport { z } from 'zod'\nimport { createApp } from './create-app'\nimport { logger } from './logger'\nimport { makeDir } from './make-dir'\n\nconst initOptionsSchema = z.object({\n  cwd: z.string(),\n  yes: z.boolean(),\n})\n\nexport const init = new Command()\n  .command('init')\n  .description('Iniciar projeto boilerplate Gseller')\n  .option('-y, --yes', 'pular a confirmação de criação do projeto', false)\n  .option(\n    '-c, --cwd <cwd>',\n    'Diretório de trabalho. O padrão é o diretório atual.',\n    process.cwd()\n  )\n  .action(async (opts) => {\n    const example = 'https://github.com/mateusp7/grv'\n\n    try {\n      const options = initOptionsSchema.parse(opts)\n      const cwd = path.resolve(options.cwd)\n\n      if (!existsSync(cwd)) {\n        logger.error(`O caminho ${cwd} não existe. Por favor, tente novamente.`)\n        process.exit(1)\n      }\n\n      const prompt = await promptQuestions(cwd)\n\n      await runInit(prompt, example)\n\n      logger.info('')\n      logger.info(`Inicialização do projeto realizada com sucesso.`)\n      logger.info('')\n    } catch (err) {}\n  })\n\nexport async function promptQuestions(cwd: string) {\n  const highlight = (text: string) => chalk.cyan(text)\n\n  const options = await prompts([\n    {\n      type: 'text',\n      name: 'path',\n      message: 'Qual o nome do projeto?',\n    },\n  ])\n\n  logger.info('')\n\n  const root = `${cwd}/${options.path}`\n  const cwdPath = existsSync(root)\n\n  if (cwdPath) {\n    logger.warn(`Já existe uma pasta com o nome de ${highlight(options.path)}`)\n    process.exit(1)\n  }\n  const spinner = ora(\n    `Criando pasta ${highlight(options.path)} do projeto.`\n  ).start()\n\n  await makeDir(cwd + '/' + options.path)\n\n  spinner.succeed()\n\n  return root\n}\n\nexport async function runInit(cwd: string, example: string) {\n  // await addNextGlobal()\n  // await startNextProject(cwd)\n  try {\n    await createApp({\n      appPath: cwd,\n      example: example,\n    })\n  } catch (reason) {}\n}\n","import retry from 'async-retry'\nimport chalk from 'chalk'\nimport fs from 'fs'\nimport path from 'path'\nimport { downloadAndExtractExample, downloadAndExtractRepo } from './download'\nimport { existsInRepo, getRepoInfo, hasRepo } from './example'\nimport { install } from './install'\nimport { isWriteable } from './is-writeable'\nimport { makeDir } from './make-dir'\n\nexport type RepoInfo = {\n  username: string\n  name: string\n  branch: string\n  filePath: string\n}\n\nexport async function createApp({\n  appPath,\n  example,\n}: {\n  appPath: string\n  example: string\n}): Promise<void> {\n  let repoInfo: RepoInfo | undefined\n\n  if (example) {\n    let repoUrl: URL | undefined\n\n    try {\n      repoUrl = new URL(example)\n    } catch (error: unknown) {\n      const err = error as Error & { code: string | undefined }\n      if (err.code !== 'ERR_INVALID_URL') {\n        console.error(error)\n        process.exit(1)\n      }\n    }\n\n    if (repoUrl) {\n      if (repoUrl.origin !== 'https://github.com') {\n        console.error(\n          `URL inválida: ${chalk.red(\n            `\"${example}\"`\n          )}. Apenas repositórios do GitHui são permitidos. Por favor, use uma URL de um repositório do GitHub e tente novamente.`\n        )\n        process.exit(1)\n      }\n\n      repoInfo = await getRepoInfo(repoUrl)\n\n      if (!repoInfo) {\n        console.error(\n          `Pasta inválida nessa URL do GitHub: ${chalk.red(\n            `\"${example}\"`\n          )}. Por favor, ajuste a URL e tente novamente.`\n        )\n        process.exit(1)\n      }\n\n      const found = await hasRepo(repoInfo)\n\n      if (!found) {\n        console.error(\n          `Não podemos encontrar a localização do repositório ${chalk.red(\n            `\"${example}\"`\n          )}. Por favor, verifique se o repositório existe e tente novamente.`\n        )\n        process.exit(1)\n      }\n    } else if (example !== '__internal-testing-retry') {\n      const found = await existsInRepo(example)\n\n      if (!found) {\n        console.error(\n          `Could not locate an example named ${chalk.red(\n            `\"${example}\"`\n          )}. It could be due to the following:\\n`,\n          `1. Your spelling of example ${chalk.red(\n            `\"${example}\"`\n          )} might be incorrect.\\n`,\n          `2. You might not be connected to the internet or you are behind a proxy.`\n        )\n        process.exit(1)\n      }\n    }\n  }\n\n  const root = path.resolve(appPath)\n\n  if (!(await isWriteable(path.dirname(root)))) {\n    console.error(\n      'A aplicação não pode ser escrita, por favor verifique as permissões da pasta e tente novamente.'\n    )\n    process.exit(1)\n  }\n\n  const appName = path.basename(root)\n\n  await makeDir(root)\n  const useYarn = 'yarn'\n  const originalDirectory = process.cwd()\n\n  console.log(`Criando um novo projeto Gseller em ${chalk.green(root)}.`)\n  console.log()\n\n  process.chdir(root)\n\n  const packageJsonPath = path.join(root, 'package.json')\n  let hasPackageJson = false\n\n  if (example) {\n    try {\n      if (repoInfo) {\n        const repoInfo2 = repoInfo\n        console.log(\n          `Baixando arquivos do repositório ${chalk.cyan(\n            example\n          )}. Isso pode demorar um pouco.`\n        )\n        console.log()\n        await retry(() => downloadAndExtractRepo(root, repoInfo2), {\n          retries: 3,\n        })\n      } else {\n        console.log(\n          `Baixando arquivos do repositório ${chalk.cyan(\n            example\n          )}. Isso pode demorar um pouco.`\n        )\n        console.log()\n        await retry(() => downloadAndExtractExample(root, example), {\n          retries: 3,\n        })\n      }\n    } catch (reason) {}\n    hasPackageJson = fs.existsSync(packageJsonPath)\n    if (hasPackageJson) {\n      console.log('Installing packages. This might take a couple of minutes.')\n      console.log()\n\n      await install('yarn', true)\n      console.log()\n    }\n  }\n  let cdpath: string\n  if (path.join(originalDirectory, appName) === appPath) {\n    cdpath = appName\n  } else {\n    cdpath = appPath\n  }\n\n  console.log(`${chalk.green('Sucesso!')} Criando ${appName} em ${appPath}`)\n}\n","import { createWriteStream, promises as fs } from 'fs'\nimport got from 'got'\nimport { tmpdir } from 'os'\nimport { join } from 'path'\nimport { Stream } from 'stream'\nimport tar from 'tar'\nimport { promisify } from 'util'\nimport { RepoInfo } from './create-app'\n\nconst pipeline = promisify(Stream.pipeline)\n\nasync function downloadTar(url: string) {\n  const tempFile = join(tmpdir(), `next.js-cna-example.temp-${Date.now()}`)\n  await pipeline(got.stream(url), createWriteStream(tempFile))\n  return tempFile\n}\n\nexport async function downloadAndExtractRepo(\n  root: string,\n  { username, name, branch, filePath }: RepoInfo\n) {\n  const tempFile = await downloadTar(\n    `https://codeload.github.com/${username}/${name}/tar.gz/${branch}`\n  )\n\n  await tar.x({\n    file: tempFile,\n    cwd: root,\n    strip: filePath ? filePath.split('/').length + 1 : 1,\n    filter: (p) =>\n      p.startsWith(\n        `${name}-${branch.replace(/\\//g, '-')}${\n          filePath ? `/${filePath}/` : '/'\n        }`\n      ),\n  })\n\n  await fs.unlink(tempFile)\n}\n\n\nexport async function downloadAndExtractExample(root: string, name: string) {\n  if (name === '__internal-testing-retry') {\n    throw new Error('This is an internal example for testing the CLI.')\n  }\n\n  const tempFile = await downloadTar(\n    'https://codeload.github.com/vercel/next.js/tar.gz/canary'\n  )\n\n  await tar.x({\n    file: tempFile,\n    cwd: root,\n    strip: 2 + name.split('/').length,\n    filter: (p) => p.includes(`next.js-canary/examples/${name}/`),\n  })\n\n  await fs.unlink(tempFile)\n}\n","import got from 'got'\nimport { RepoInfo } from './create-app'\n\nexport async function isUrlOk(url: string): Promise<boolean> {\n  const res = await got.head(url).catch((e) => e)\n  return res.statusCode === 200\n}\n\nexport async function getRepoInfo(\n  url: URL,\n  examplePath?: string\n): Promise<RepoInfo | undefined> {\n  const [, username, name, t, _branch, ...file] = url.pathname.split('/')\n  const filePath = examplePath ? examplePath.replace(/^\\//, '') : file.join('/')\n\n  if (\n    // Support repos whose entire purpose is to be a Next.js example, e.g.\n    // https://github.com/:username/:my-cool-nextjs-example-repo-name.\n    t === undefined ||\n    // Support GitHub URL that ends with a trailing slash, e.g.\n    // https://github.com/:username/:my-cool-nextjs-example-repo-name/\n    // In this case \"t\" will be an empty string while the next part \"_branch\" will be undefined\n    (t === '' && _branch === undefined)\n  ) {\n    const infoResponse = await got(\n      `https://api.github.com/repos/${username}/${name}`\n    ).catch((e) => e)\n    if (infoResponse.statusCode !== 200) {\n      return\n    }\n    const info = JSON.parse(infoResponse.body)\n    return { username, name, branch: info['default_branch'], filePath }\n  }\n\n  // If examplePath is available, the branch name takes the entire path\n  const branch = examplePath\n    ? `${_branch}/${file.join('/')}`.replace(new RegExp(`/${filePath}|/$`), '')\n    : _branch\n\n  if (username && name && branch && t === 'tree') {\n    return { username, name, branch, filePath }\n  }\n}\n\nexport function hasRepo({\n  username,\n  name,\n  branch,\n  filePath,\n}: RepoInfo): Promise<boolean> {\n  const contentsUrl = `https://api.github.com/repos/${username}/${name}/contents`\n  const packagePath = `${filePath ? `/${filePath}` : ''}/package.json`\n\n  return isUrlOk(contentsUrl + packagePath + `?ref=${branch}`)\n}\n\nexport function existsInRepo(nameOrUrl: string): Promise<boolean> {\n  try {\n    const url = new URL(nameOrUrl)\n    return isUrlOk(url.href)\n  } catch {\n    return isUrlOk(\n      `https://api.github.com/repos/vercel/next.js/contents/examples/${encodeURIComponent(\n        nameOrUrl\n      )}`\n    )\n  }\n}\n","import chalk from 'chalk'\nimport spawn from 'cross-spawn'\nimport ora from 'ora'\n\nexport async function install(\n  /** Indicate which package manager to use. */\n  packageManager: string,\n  /** Indicate whether there is an active Internet connection.*/\n  isOnline: boolean\n): Promise<void> {\n  let args: string[] = ['install']\n  if (!isOnline) {\n    console.log(\n      chalk.yellow(\n        'You appear to be offline.\\nFalling back to the local cache.'\n      )\n    )\n    args.push('--offline')\n  }\n  /**\n   * Return a Promise that resolves once the installation is finished.\n   */\n  return new Promise((resolve, reject) => {\n    /**\n     * Spawn the installation process.\n     */\n    const child = spawn(packageManager, args, {\n      stdio: 'inherit',\n      env: {\n        ...process.env,\n        ADBLOCK: '1',\n        // we set NODE_ENV to development as pnpm skips dev\n        // dependencies when production\n        NODE_ENV: 'development',\n        DISABLE_OPENCOLLECTIVE: '1',\n      },\n    })\n    child.on('close', (code) => {\n      if (code !== 0) {\n        reject({ command: `${packageManager} ${args.join(' ')}` })\n        return\n      }\n      resolve()\n    })\n  })\n}\n\nexport async function addNextGlobal(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const spinner = ora(`Iniciando instalação do next globalmente`).start()\n    const child = spawn('npm', ['i', '-g', 'create-next-app'])\n    spinner.succeed()\n    child.on('close', (code) => {\n      if (code !== 0) {\n        spinner.fail(\n          'Erro ao instalar next globalmente. Por favor, tente novamente'\n        )\n        return reject(new Error('Failed'))\n      }\n      return resolve()\n    })\n  })\n}\n\nexport async function startNextProject(cwd: string): Promise<void> {\n  {\n    return new Promise((resolve, reject) => {\n      const spinner = ora(`Iniciando instalação do app next`).start()\n      const child = spawn('npx', ['create-next-app@latest', cwd], {\n        stdio: 'inherit',\n        cwd,\n      })\n      spinner.succeed()\n      child.on('close', (code) => {\n        if (code !== 0) {\n          return reject(new Error('Failed'))\n        }\n        return resolve()\n      })\n    })\n  }\n}\n","import fs from 'fs'\n\nexport async function isWriteable(directory: string): Promise<boolean> {\n  try {\n    await fs.promises.access(directory, (fs.constants || fs).W_OK)\n    return true\n  } catch (err) {\n    return false\n  }\n}\n","import fs from 'fs'\n\nexport function makeDir(\n  root: string,\n  options = { recursive: true }\n): Promise<string | undefined> {\n  return fs.promises.mkdir(root, options)\n}\n","import chalk from 'chalk'\n\nexport const logger = {\n  error(...args: unknown[]) {\n    console.log(chalk.red(...args))\n  },\n  warn(...args: unknown[]) {\n    console.log(chalk.yellow(...args))\n  },\n  info(...args: unknown[]) {\n    console.log(chalk.cyan(...args))\n  },\n  success(...args: unknown[]) {\n    console.log(chalk.green(...args))\n  },\n  break() {\n    console.log('')\n  },\n}\n"],"mappings":"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","names":["Command","Command","existsSync","ora","path","chalk","prompts","z","retry","chalk","fs","path","createWriteStream","fs","got","tmpdir","join","Stream","tar","promisify","pipeline","downloadTar","url","tempFile","downloadAndExtractRepo","root","username","name","branch","filePath","p","downloadAndExtractExample","got","isUrlOk","url","e","getRepoInfo","examplePath","username","name","t","_branch","file","filePath","infoResponse","info","branch","hasRepo","contentsUrl","packagePath","existsInRepo","nameOrUrl","chalk","spawn","ora","install","packageManager","isOnline","args","resolve","reject","code","fs","isWriteable","directory","fs","makeDir","root","options","createApp","appPath","example","repoInfo","repoUrl","error","chalk","getRepoInfo","hasRepo","existsInRepo","root","path","isWriteable","appName","makeDir","useYarn","originalDirectory","packageJsonPath","hasPackageJson","repoInfo2","retry","downloadAndExtractRepo","downloadAndExtractExample","fs","install","cdpath","chalk","logger","args","initOptionsSchema","z","init","Command","opts","example","options","cwd","path","existsSync","logger","prompt","promptQuestions","runInit","highlight","text","chalk","prompts","root","spinner","ora","makeDir","createApp","program","Command","main","init"]}