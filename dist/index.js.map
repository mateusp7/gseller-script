{"version":3,"sources":["../src/index.ts","../src/commands/init.ts","../src/helpers/create-app.ts","../src/helpers/download.ts","../src/helpers/example.ts","../src/helpers/install.ts","../src/helpers/get-config.ts","../src/helpers/resolve-import.ts","../src/helpers/logger.ts"],"sourcesContent":["#!/usr/bin/env node\r\nimport { Command } from 'commander'\r\nimport { init } from './commands/init'\r\n\r\nconst program = new Command()\r\nasync function main() {\r\n  program\r\n    .name('gseller')\r\n    .description('Criar um template teste')\r\n    .version('1.0.0', '-v, --version', 'display the version number')\r\n\r\n  program.addCommand(init)\r\n  program.parse()\r\n}\r\n\r\nmain()\r\n","import { Command } from 'commander'\r\nimport { existsSync, promises as fs } from 'fs'\r\nimport ora from 'ora'\r\nimport path from 'path'\r\n\r\nimport chalk from 'chalk'\r\nimport prompts from 'prompts'\r\nimport { z } from 'zod'\r\nimport { createApp } from '../helpers/create-app'\r\nimport {\r\n  Config,\r\n  DEFAULT_COMPONENTS,\r\n  DEFAULT_GRAPHQL,\r\n  DEFAULT_TAILWIND_CONFIG,\r\n  DEFAULT_TAILWIND_CSS,\r\n  DEFAULT_UTILS,\r\n  getConfig,\r\n  rawConfigSchema,\r\n} from '../helpers/get-config'\r\nimport { logger } from '../helpers/logger'\r\n\r\nconst initOptionsSchema = z.object({\r\n  cwd: z.string(),\r\n  yes: z.boolean(),\r\n})\r\n\r\nexport const init = new Command()\r\n  .command('init')\r\n  .description('Iniciar projeto boilerplate Gseller')\r\n  .option('-y, --yes', 'pular a confirmação de criação do projeto', false)\r\n  .option(\r\n    '-c, --cwd <cwd>',\r\n    'Diretório de trabalho. O padrão é o diretório atual.',\r\n    process.cwd()\r\n  )\r\n  .action(async (opts) => {\r\n    const example = 'https://github.com/mateusp7/grv'\r\n\r\n    try {\r\n      const options = initOptionsSchema.parse(opts)\r\n      const cwd = path.resolve(options.cwd)\r\n\r\n      if (!existsSync(cwd)) {\r\n        logger.error(`O caminho ${cwd} não existe. Por favor, tente novamente.`)\r\n        process.exit(1)\r\n      }\r\n\r\n      const existingConfig = await getConfig(cwd)\r\n      const prompt = await promptForConfig(existingConfig)\r\n\r\n      // await runInit(prompt, example)\r\n\r\n      logger.info('')\r\n      logger.info(`Inicialização do projeto realizada com sucesso.`)\r\n      logger.info('')\r\n    } catch (err) {}\r\n  })\r\n\r\nexport async function promptForConfig(defaultConfig: Config | null = null) {\r\n  const highlight = (text: string) => chalk.cyan(text)\r\n\r\n  const options = await prompts([\r\n    {\r\n      type: 'text',\r\n      name: 'graphql',\r\n      message: `Aonde está localizado a pasta ${highlight('graphql')}?`,\r\n      initial: defaultConfig?.graphql ?? DEFAULT_GRAPHQL,\r\n    },\r\n    {\r\n      type: 'text',\r\n      name: 'tailwindConfig',\r\n      message: `Aonde está localizado a pasta ${highlight(\r\n        'tailwind.config.js'\r\n      )}?`,\r\n      initial: defaultConfig?.tailwind.config ?? DEFAULT_TAILWIND_CONFIG,\r\n    },\r\n    {\r\n      type: 'text',\r\n      name: 'tailwindCss',\r\n      message: `Aonde está localizado o arquivo ${highlight('global CSS')}?`,\r\n      initial: defaultConfig?.tailwind.css ?? DEFAULT_TAILWIND_CSS,\r\n    },\r\n    {\r\n      type: 'text',\r\n      name: 'components',\r\n      message: `Configure o alias de importação para ${highlight(\r\n        'components'\r\n      )}:`,\r\n      initial: defaultConfig?.aliases['components'] ?? DEFAULT_COMPONENTS,\r\n    },\r\n    {\r\n      type: 'text',\r\n      name: 'utils',\r\n      message: `Configure o alias de importação para ${highlight('utils')}:`,\r\n      initial: defaultConfig?.aliases['utils'] ?? DEFAULT_UTILS,\r\n    },\r\n  ])\r\n\r\n  const config = rawConfigSchema.parse({\r\n    tsx: true,\r\n    graphql: options.graphql,\r\n    tailwind: {\r\n      config: options.tailwindConfig,\r\n      css: options.tailwindCss,\r\n    },\r\n    aliases: {\r\n      utils: options.utils,\r\n      components: options.components,\r\n    },\r\n  })\r\n\r\n  const resolvedProjectPath = path.resolve()\r\n  logger.info('')\r\n\r\n  createGsellerJson(resolvedProjectPath, config)\r\n\r\n  return resolvedProjectPath\r\n}\r\n\r\nexport async function createGsellerJson(\r\n  cwd: string,\r\n  config: z.infer<typeof rawConfigSchema>\r\n) {\r\n  logger.info('')\r\n  const spinner = ora(`Criando arquivo gseller.json...`).start()\r\n\r\n  const targetPath = path.resolve(cwd, 'gseller.json')\r\n  await fs.writeFile(targetPath, JSON.stringify(config, null, 2), 'utf-8')\r\n  spinner.succeed()\r\n}\r\n\r\nexport async function runInit(cwd: string, example: string) {\r\n  // await addNextGlobal()\r\n  // await startNextProject(cwd)\r\n  try {\r\n    await createApp({\r\n      appPath: cwd,\r\n      example: example,\r\n    })\r\n  } catch (reason) {}\r\n}\r\n","import retry from 'async-retry'\r\nimport chalk from 'chalk'\r\nimport fs from 'fs'\r\nimport path from 'path'\r\nimport { downloadAndExtractExample, downloadAndExtractRepo } from './download'\r\nimport { existsInRepo, getRepoInfo, hasRepo } from './example'\r\nimport { install } from './install'\r\nimport { isWriteable } from './is-writeable'\r\nimport { makeDir } from './make-dir'\r\n\r\nexport type RepoInfo = {\r\n  username: string\r\n  name: string\r\n  branch: string\r\n  filePath: string\r\n}\r\n\r\nexport async function createApp({\r\n  appPath,\r\n  example,\r\n}: {\r\n  appPath: string\r\n  example: string\r\n}): Promise<void> {\r\n  let repoInfo: RepoInfo | undefined\r\n\r\n  if (example) {\r\n    let repoUrl: URL | undefined\r\n\r\n    try {\r\n      repoUrl = new URL(example)\r\n    } catch (error: unknown) {\r\n      const err = error as Error & { code: string | undefined }\r\n      if (err.code !== 'ERR_INVALID_URL') {\r\n        console.error(error)\r\n        process.exit(1)\r\n      }\r\n    }\r\n\r\n    if (repoUrl) {\r\n      if (repoUrl.origin !== 'https://github.com') {\r\n        console.error(\r\n          `URL inválida: ${chalk.red(\r\n            `\"${example}\"`\r\n          )}. Apenas repositórios do GitHui são permitidos. Por favor, use uma URL de um repositório do GitHub e tente novamente.`\r\n        )\r\n        process.exit(1)\r\n      }\r\n\r\n      repoInfo = await getRepoInfo(repoUrl)\r\n\r\n      if (!repoInfo) {\r\n        console.error(\r\n          `Pasta inválida nessa URL do GitHub: ${chalk.red(\r\n            `\"${example}\"`\r\n          )}. Por favor, ajuste a URL e tente novamente.`\r\n        )\r\n        process.exit(1)\r\n      }\r\n\r\n      const found = await hasRepo(repoInfo)\r\n\r\n      if (!found) {\r\n        console.error(\r\n          `Não podemos encontrar a localização do repositório ${chalk.red(\r\n            `\"${example}\"`\r\n          )}. Por favor, verifique se o repositório existe e tente novamente.`\r\n        )\r\n        process.exit(1)\r\n      }\r\n    } else if (example !== '__internal-testing-retry') {\r\n      const found = await existsInRepo(example)\r\n\r\n      if (!found) {\r\n        console.error(\r\n          `Could not locate an example named ${chalk.red(\r\n            `\"${example}\"`\r\n          )}. It could be due to the following:\\n`,\r\n          `1. Your spelling of example ${chalk.red(\r\n            `\"${example}\"`\r\n          )} might be incorrect.\\n`,\r\n          `2. You might not be connected to the internet or you are behind a proxy.`\r\n        )\r\n        process.exit(1)\r\n      }\r\n    }\r\n  }\r\n\r\n  const root = path.resolve(appPath)\r\n\r\n  if (!(await isWriteable(path.dirname(root)))) {\r\n    console.error(\r\n      'A aplicação não pode ser escrita, por favor verifique as permissões da pasta e tente novamente.'\r\n    )\r\n    process.exit(1)\r\n  }\r\n\r\n  const appName = path.basename(root)\r\n\r\n  await makeDir(root)\r\n  const useYarn = 'yarn'\r\n  const originalDirectory = process.cwd()\r\n\r\n  console.log(`Criando um novo projeto Gseller em ${chalk.green(root)}.`)\r\n  console.log()\r\n\r\n  process.chdir(root)\r\n\r\n  const packageJsonPath = path.join(root, 'package.json')\r\n  let hasPackageJson = false\r\n\r\n  if (example) {\r\n    try {\r\n      if (repoInfo) {\r\n        const repoInfo2 = repoInfo\r\n        console.log(\r\n          `Baixando arquivos do repositório ${chalk.cyan(\r\n            example\r\n          )}. Isso pode demorar um pouco.`\r\n        )\r\n        console.log()\r\n        await retry(() => downloadAndExtractRepo(root, repoInfo2), {\r\n          retries: 3,\r\n        })\r\n      } else {\r\n        console.log(\r\n          `Baixando arquivos do repositório ${chalk.cyan(\r\n            example\r\n          )}. Isso pode demorar um pouco.`\r\n        )\r\n        console.log()\r\n        await retry(() => downloadAndExtractExample(root, example), {\r\n          retries: 3,\r\n        })\r\n      }\r\n    } catch (reason) {}\r\n    hasPackageJson = fs.existsSync(packageJsonPath)\r\n    if (hasPackageJson) {\r\n      console.log('Installing packages. This might take a couple of minutes.')\r\n      console.log()\r\n\r\n      await install('yarn', true)\r\n      console.log()\r\n    }\r\n  }\r\n  let cdpath: string\r\n  if (path.join(originalDirectory, appName) === appPath) {\r\n    cdpath = appName\r\n  } else {\r\n    cdpath = appPath\r\n  }\r\n\r\n  console.log(`${chalk.green('Sucesso!')} Criando ${appName} em ${appPath}`)\r\n}\r\n","import { createWriteStream, promises as fs } from 'fs'\r\nimport got from 'got'\r\nimport { tmpdir } from 'os'\r\nimport { join } from 'path'\r\nimport { Stream } from 'stream'\r\nimport tar from 'tar'\r\nimport { promisify } from 'util'\r\nimport { RepoInfo } from './create-app'\r\n\r\nconst pipeline = promisify(Stream.pipeline)\r\n\r\nasync function downloadTar(url: string) {\r\n  const tempFile = join(tmpdir(), `next.js-cna-example.temp-${Date.now()}`)\r\n  await pipeline(got.stream(url), createWriteStream(tempFile))\r\n  return tempFile\r\n}\r\n\r\nexport async function downloadAndExtractRepo(\r\n  root: string,\r\n  { username, name, branch, filePath }: RepoInfo\r\n) {\r\n  const tempFile = await downloadTar(\r\n    `https://codeload.github.com/${username}/${name}/tar.gz/${branch}`\r\n  )\r\n\r\n  await tar.x({\r\n    file: tempFile,\r\n    cwd: root,\r\n    strip: filePath ? filePath.split('/').length + 1 : 1,\r\n    filter: (p) =>\r\n      p.startsWith(\r\n        `${name}-${branch.replace(/\\//g, '-')}${\r\n          filePath ? `/${filePath}/` : '/'\r\n        }`\r\n      ),\r\n  })\r\n\r\n  await fs.unlink(tempFile)\r\n}\r\n\r\nexport async function downloadAndExtractExample(root: string, name: string) {\r\n  if (name === '__internal-testing-retry') {\r\n    throw new Error('This is an internal example for testing the CLI.')\r\n  }\r\n\r\n  const tempFile = await downloadTar(\r\n    'https://codeload.github.com/vercel/next.js/tar.gz/canary'\r\n  )\r\n\r\n  await tar.x({\r\n    file: tempFile,\r\n    cwd: root,\r\n    strip: 2 + name.split('/').length,\r\n    filter: (p) => p.includes(`next.js-canary/examples/${name}/`),\r\n  })\r\n\r\n  await fs.unlink(tempFile)\r\n}\r\n","import got from 'got'\r\nimport { RepoInfo } from './create-app'\r\n\r\nexport async function isUrlOk(url: string): Promise<boolean> {\r\n  const res = await got.head(url).catch((e) => e)\r\n  return res.statusCode === 200\r\n}\r\n\r\nexport async function getRepoInfo(\r\n  url: URL,\r\n  examplePath?: string\r\n): Promise<RepoInfo | undefined> {\r\n  const [, username, name, t, _branch, ...file] = url.pathname.split('/')\r\n  const filePath = examplePath ? examplePath.replace(/^\\//, '') : file.join('/')\r\n\r\n  if (\r\n    // Support repos whose entire purpose is to be a Next.js example, e.g.\r\n    // https://github.com/:username/:my-cool-nextjs-example-repo-name.\r\n    t === undefined ||\r\n    // Support GitHub URL that ends with a trailing slash, e.g.\r\n    // https://github.com/:username/:my-cool-nextjs-example-repo-name/\r\n    // In this case \"t\" will be an empty string while the next part \"_branch\" will be undefined\r\n    (t === '' && _branch === undefined)\r\n  ) {\r\n    const infoResponse = await got(\r\n      `https://api.github.com/repos/${username}/${name}`\r\n    ).catch((e) => e)\r\n    if (infoResponse.statusCode !== 200) {\r\n      return\r\n    }\r\n    const info = JSON.parse(infoResponse.body)\r\n    return { username, name, branch: info['default_branch'], filePath }\r\n  }\r\n\r\n  // If examplePath is available, the branch name takes the entire path\r\n  const branch = examplePath\r\n    ? `${_branch}/${file.join('/')}`.replace(new RegExp(`/${filePath}|/$`), '')\r\n    : _branch\r\n\r\n  if (username && name && branch && t === 'tree') {\r\n    return { username, name, branch, filePath }\r\n  }\r\n}\r\n\r\nexport function hasRepo({\r\n  username,\r\n  name,\r\n  branch,\r\n  filePath,\r\n}: RepoInfo): Promise<boolean> {\r\n  const contentsUrl = `https://api.github.com/repos/${username}/${name}/contents`\r\n  const packagePath = `${filePath ? `/${filePath}` : ''}/package.json`\r\n\r\n  return isUrlOk(contentsUrl + packagePath + `?ref=${branch}`)\r\n}\r\n\r\nexport function existsInRepo(nameOrUrl: string): Promise<boolean> {\r\n  try {\r\n    const url = new URL(nameOrUrl)\r\n    return isUrlOk(url.href)\r\n  } catch {\r\n    return isUrlOk(\r\n      `https://api.github.com/repos/vercel/next.js/contents/examples/${encodeURIComponent(\r\n        nameOrUrl\r\n      )}`\r\n    )\r\n  }\r\n}\r\n","import chalk from 'chalk'\r\nimport spawn from 'cross-spawn'\r\nimport ora from 'ora'\r\n\r\nexport async function install(\r\n  /** Indicate which package manager to use. */\r\n  packageManager: string,\r\n  /** Indicate whether there is an active Internet connection.*/\r\n  isOnline: boolean\r\n): Promise<void> {\r\n  let args: string[] = ['install']\r\n  if (!isOnline) {\r\n    console.log(\r\n      chalk.yellow(\r\n        'You appear to be offline.\\nFalling back to the local cache.'\r\n      )\r\n    )\r\n    args.push('--offline')\r\n  }\r\n  /**\r\n   * Return a Promise that resolves once the installation is finished.\r\n   */\r\n  return new Promise((resolve, reject) => {\r\n    /**\r\n     * Spawn the installation process.\r\n     */\r\n    const child = spawn(packageManager, args, {\r\n      stdio: 'inherit',\r\n      env: {\r\n        ...process.env,\r\n        ADBLOCK: '1',\r\n        // we set NODE_ENV to development as pnpm skips dev\r\n        // dependencies when production\r\n        NODE_ENV: 'development',\r\n        DISABLE_OPENCOLLECTIVE: '1',\r\n      },\r\n    })\r\n    child.on('close', (code) => {\r\n      if (code !== 0) {\r\n        reject({ command: `${packageManager} ${args.join(' ')}` })\r\n        return\r\n      }\r\n      resolve()\r\n    })\r\n  })\r\n}\r\n\r\nexport async function addNextGlobal(): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    const spinner = ora(`Iniciando instalação do next globalmente`).start()\r\n    const child = spawn('npm', ['i', '-g', 'create-next-app'])\r\n    spinner.succeed()\r\n    child.on('close', (code) => {\r\n      if (code !== 0) {\r\n        spinner.fail(\r\n          'Erro ao instalar next globalmente. Por favor, tente novamente'\r\n        )\r\n        return reject(new Error('Failed'))\r\n      }\r\n      return resolve()\r\n    })\r\n  })\r\n}\r\n\r\nexport async function startNextProject(cwd: string): Promise<void> {\r\n  {\r\n    return new Promise((resolve, reject) => {\r\n      const spinner = ora(`Iniciando instalação do app next`).start()\r\n      const child = spawn('npx', ['create-next-app@latest', cwd], {\r\n        stdio: 'inherit',\r\n        cwd,\r\n      })\r\n      spinner.succeed()\r\n      child.on('close', (code) => {\r\n        if (code !== 0) {\r\n          return reject(new Error('Failed'))\r\n        }\r\n        return resolve()\r\n      })\r\n    })\r\n  }\r\n}\r\n","import { cosmiconfig } from 'cosmiconfig'\r\nimport path from 'path'\r\nimport { loadConfig } from 'tsconfig-paths'\r\nimport { z } from 'zod'\r\nimport { resolveImport } from './resolve-import'\r\n\r\nexport const DEFAULT_COMPONENTS = '@/components'\r\nexport const DEFAULT_UTILS = '@/lib/utils'\r\nexport const DEFAULT_TAILWIND_CSS = 'src/app/globals.css'\r\nexport const DEFAULT_TAILWIND_CONFIG = 'tailwind.config.js'\r\nexport const DEFAULT_GRAPHQL = 'src/app/graphql'\r\n\r\nconst explorer = cosmiconfig('components', {\r\n  searchPlaces: ['components.json'],\r\n})\r\n\r\nexport const rawConfigSchema = z\r\n  .object({\r\n    tsx: z.coerce.boolean().default(true),\r\n    graphql: z.string(),\r\n    tailwind: z.object({\r\n      config: z.string(),\r\n      css: z.string(),\r\n    }),\r\n    aliases: z.object({\r\n      components: z.string(),\r\n      utils: z.string(),\r\n    }),\r\n  })\r\n  .strict()\r\n\r\nexport type RawConfig = z.infer<typeof rawConfigSchema>\r\n\r\nexport const configSchema = rawConfigSchema.extend({\r\n  resolvedPaths: z.object({\r\n    tailwindConfig: z.string(),\r\n    tailwindCss: z.string(),\r\n    utils: z.string(),\r\n    components: z.string(),\r\n  }),\r\n})\r\n\r\nexport type Config = z.infer<typeof configSchema>\r\n\r\nexport async function getConfig(cwd: string) {\r\n  const config = await getRawConfig(cwd)\r\n\r\n  if (!config) {\r\n    return null\r\n  }\r\n\r\n  return await resolveConfigPaths(cwd, config)\r\n}\r\n\r\nexport async function resolveConfigPaths(cwd: string, config: RawConfig) {\r\n  // Read tsconfig.json.\r\n  const tsConfig = loadConfig(cwd)\r\n\r\n  if (tsConfig.resultType === 'failed') {\r\n    throw new Error(\r\n      `Failed to load ${config.tsx ? 'tsconfig' : 'jsconfig'}.json. ${\r\n        tsConfig.message ?? ''\r\n      }`.trim()\r\n    )\r\n  }\r\n\r\n  return configSchema.parse({\r\n    ...config,\r\n    resolvedPaths: {\r\n      graphql: path.resolve(cwd, config.graphql),\r\n      tailwindConfig: path.resolve(cwd, config.tailwind.config),\r\n      tailwindCss: path.resolve(cwd, config.tailwind.css),\r\n      utils: await resolveImport(config.aliases['utils'], tsConfig),\r\n      components: await resolveImport(config.aliases['components'], tsConfig),\r\n    },\r\n  })\r\n}\r\n\r\nexport async function getRawConfig(cwd: string): Promise<RawConfig | null> {\r\n  try {\r\n    const configResult = await explorer.search(cwd)\r\n\r\n    if (!configResult) {\r\n      return null\r\n    }\r\n\r\n    return rawConfigSchema.parse(configResult.config)\r\n  } catch (error) {\r\n    throw new Error(`Invalid configuration found in ${cwd}/components.json.`)\r\n  }\r\n}\r\n","import { createMatchPath, type ConfigLoaderSuccessResult } from 'tsconfig-paths'\r\n\r\nexport async function resolveImport(\r\n  importPath: string,\r\n  config: Pick<ConfigLoaderSuccessResult, 'absoluteBaseUrl' | 'paths'>\r\n) {\r\n  return createMatchPath(config.absoluteBaseUrl, config.paths)(\r\n    importPath,\r\n    undefined,\r\n    () => true,\r\n    ['.ts', '.tsx']\r\n  )\r\n}\r\n","import chalk from 'chalk'\r\n\r\nexport const logger = {\r\n  error(...args: unknown[]) {\r\n    console.log(chalk.red(...args))\r\n  },\r\n  warn(...args: unknown[]) {\r\n    console.log(chalk.yellow(...args))\r\n  },\r\n  info(...args: unknown[]) {\r\n    console.log(chalk.cyan(...args))\r\n  },\r\n  success(...args: unknown[]) {\r\n    console.log(chalk.green(...args))\r\n  },\r\n  break() {\r\n    console.log('')\r\n  },\r\n}\r\n"],"mappings":"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","names":["Command","Command","existsSync","fs","ora","path","chalk","prompts","z","retry","chalk","got","Stream","tar","promisify","pipeline","got","chalk","spawn","ora","cosmiconfig","path","loadConfig","z","createMatchPath","resolveImport","importPath","config","DEFAULT_COMPONENTS","DEFAULT_UTILS","DEFAULT_TAILWIND_CSS","DEFAULT_TAILWIND_CONFIG","DEFAULT_GRAPHQL","explorer","cosmiconfig","rawConfigSchema","z","configSchema","getConfig","cwd","config","getRawConfig","resolveConfigPaths","tsConfig","loadConfig","path","resolveImport","configResult","chalk","logger","args","initOptionsSchema","z","init","Command","opts","example","options","cwd","path","existsSync","logger","existingConfig","getConfig","prompt","promptForConfig","defaultConfig","highlight","text","chalk","prompts","DEFAULT_GRAPHQL","DEFAULT_TAILWIND_CONFIG","DEFAULT_TAILWIND_CSS","DEFAULT_COMPONENTS","DEFAULT_UTILS","config","rawConfigSchema","resolvedProjectPath","createGsellerJson","spinner","ora","targetPath","fs","program","Command","main","init"]}